# hpl/HPLConfig.py

import os
import math
import shutil
import subprocess
from pathlib import Path
from typing import Tuple, List, Optional, Dict
import logging


class HPLConfig:
    """
    Generates and manages HPL benchmark configurations based on user-defined parameters.
    """

    SCRIPT_PATH = Path(__file__).parent / "HPLInstall.sh"

    def __init__(self, output_dir: str = "/tmp/hpl_configs"):
        """
        Initialize the HPLConfig.

        Args:
            output_dir (str): Directory to save the generated configurations.
        """
        self.output_dir = Path(output_dir)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("HPLConfig initialized.")

    def _generate_hpl_file(
        self,
        file_name: str,
        n_value: int,
        nb: int,
        ps: int,
        qs: int,
        custom_params: Optional[Dict[str, str]] = None,
    ) -> Path:
        """
        Generate the HPL configuration file.

        Args:
            file_name (str): Name of the configuration file.
            n_value (int): Problem size N.
            nb (int): Block size.
            ps (int): Process grid P.
            qs (int): Process grid Q.
            custom_params (Optional[Dict[str, str]]): Additional custom HPL parameters.

        Returns:
            Path: Path to the generated configuration file.
        """
        config_dir = self.output_dir / "custom"
        config_dir.mkdir(parents=True, exist_ok=True)
        file_path = config_dir / file_name

        hpl_template = (
            f"HPLinpack benchmark input file\n"
            f"Generated by HPLConfig\n"
            f"HPL.out      output file name (if any)\n"
            f"6            device out (6=stdout,7=stderr,file)\n"
            f"1            # of problems sizes (N)\n"
            f"{n_value}    Ns\n"
            f"1            # of NBs\n"
            f"{nb}         NBs\n"
            f"0            PMAP process mapping (0=Row-,1=Column-major)\n"
            f"1            # of process grids (P x Q)\n"
            f"{ps}         Ps\n"
            f"{qs}         Qs\n"
            f"16.0         threshold\n"
            f"1            # of panel fact\n"
            f"2            PFACTs (0=left, 1=Crout, 2=Right)\n"
            f"1            # of recursive stopping criterium\n"
            f"4            NBMINs (>= 1)\n"
            f"1            # of panels in recursion\n"
            f"2            NDIVs\n"
            f"1            # of recursive panel fact.\n"
            f"1            RFACTs (0=left, 1=Crout, 2=Right)\n"
            f"1            # of broadcast\n"
            f"1            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)\n"
            f"1            # of lookahead depth\n"
            f"1            DEPTHs (>=0)\n"
            f"2            SWAP (0=bin-exch,1=long,2=mix)\n"
            f"64           swapping threshold\n"
            f"0            L1 in (0=transposed,1=no-transposed) form\n"
            f"0            U  in (0=transposed,1=no-transposed) form\n"
            f"1            Equilibration (0=no,1=yes)\n"
            f"8            memory alignment in double (> 0)\n"
            f"##### This line (no. 32) is ignored (it serves as a separator). ######\n"
            f"0                               Number of additional problem sizes for PTRANS\n"
            f"1200 10000 30000                values of N\n"
            f"0                               number of additional blocking sizes for PTRANS\n"
            f"40 9 8 13 13 20 16 32 64        values of NB\n"
        )

        if custom_params:
            for key, value in custom_params.items():
                hpl_template += f"{key} {value}\n"

        with open(file_path, "w") as f:
            f.write(hpl_template)

        self.logger.info(f"HPL configuration file generated at {file_path}")
        return file_path

    def generate_hpl_config(
        self, n: int, nb: int, p: int, q: int
    ) -> Tuple[Path, int]:
        """
        Retrieve configuration based on direct specification of N, NB, P, Q.

        Args:
            n (int): Problem size N.
            nb (int): Block size.
            p (int): Process grid P.
            q (int): Process grid Q.
            competitive (bool): Competitive mode flag.

        Returns:
            Tuple[Path, int]: Path to the configuration file and number of instances.
        """
        self.logger.debug(
            f"Generating custom config with N={n}, NB={nb}, P={p}, Q={q}"
        )

        file_name = f"hpl_N{n}_NB{nb}_P{p}_Q{q}.dat"
        config_path = self._generate_hpl_file(file_name, n, nb, p, q)

        return config_path

    def generate_hosts_file(self, nodes: Dict[str, int]) -> Path:
        """
        Generate the hosts file for the HPL benchmark.
        The filename is fixed to 'hosts.txt'.
        """
        hosts_file = self.output_dir / "hosts.txt"

        with open(hosts_file, "w") as f:
            for node, slots in nodes.items():
                f.write(f"{node} slots={slots}\n")

        self.logger.info(f"Hosts file generated at {hosts_file}")
        return hosts_file
